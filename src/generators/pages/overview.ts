import path from "path";
import type { DocWalkConfig } from "../../config/schema.js";
import type { AnalysisManifest, GeneratedPage } from "../../analysis/types.js";
import type { AIProvider } from "../../analysis/providers/base.js";
import { getLanguageDisplayName, type LanguageId } from "../../analysis/language-detect.js";
import { resolveProjectName, groupModulesLogically } from "../utils.js";
import { generateOverviewNarrative, renderCitations } from "../narrative-engine.js";

export function generateOverviewPage(manifest: AnalysisManifest, config: DocWalkConfig): GeneratedPage {
  const { projectMeta: meta, stats } = manifest;
  const projectName = resolveProjectName(manifest);
  const archLink = config.analysis.architecture_tiers !== false ? "architecture/index.md" : "architecture.md";

  // Group modules by logical section for categorized navigation
  const modulesByGroup = groupModulesLogically(manifest.modules);
  const sectionLinks = Object.entries(modulesByGroup)
    .sort(([, a], [, b]) => b.length - a.length)
    .map(([section, modules]) => {
      const topModule = modules[0];
      const slug = topModule.filePath.replace(/\.[^.]+$/, "");
      return `| **[${section}](api/${slug}.md)** | ${modules.length} modules | ${modules.map((m) => `\`${path.basename(m.filePath)}\``).slice(0, 4).join(", ")}${modules.length > 4 ? `, +${modules.length - 4} more` : ""} |`;
    })
    .join("\n");

  // Top connected modules for the architecture overview
  const connectionCounts = new Map<string, number>();
  for (const edge of manifest.dependencyGraph.edges) {
    connectionCounts.set(edge.from, (connectionCounts.get(edge.from) ?? 0) + 1);
    connectionCounts.set(edge.to, (connectionCounts.get(edge.to) ?? 0) + 1);
  }
  const topModules = [...connectionCounts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);

  const coreModulesSection = topModules.length > 0
    ? `## Core Modules\n\nThe most interconnected modules in the codebase:\n\n${topModules.map(([file, count]) => {
        const slug = file.replace(/\.[^.]+$/, "");
        const mod = manifest.modules.find((m) => m.filePath === file);
        const desc = mod?.moduleDoc?.summary || "";
        return `- **[\`${path.basename(file)}\`](api/${slug}.md)** — ${desc || `${count} connections`}`;
      }).join("\n")}\n`
    : "";

  const langList = meta.languages
    .map((l) => `**${getLanguageDisplayName(l.name as LanguageId)}** (${l.fileCount} files, ${l.percentage}%)`)
    .join(" · ");

  const primaryLang = meta.languages[0]
    ? getLanguageDisplayName(meta.languages[0].name as LanguageId)
    : "software";
  const projectDescription = meta.description
    || meta.readmeDescription
    || `A ${primaryLang} project. This reference covers the full API surface, architecture, and module structure.`;

  const content = `---
title: ${projectName} Documentation
description: Technical documentation for ${projectName}
---

# ${projectName}

${projectDescription}

---

## Getting Started

New to this project? Start here:

- **[Getting Started](getting-started.md)** — Prerequisites, installation, and project structure
- **[Architecture](${archLink})** — System design, dependency graph, and module relationships
- **[API Reference](#api-by-section)** — Complete reference organized by component
${config.analysis.config_docs ? `- **[Configuration](configuration.md)** — Configuration schemas and settings\n` : ""}${config.analysis.types_page ? `- **[Types & Interfaces](types.md)** — All exported types, interfaces, and enums\n` : ""}${config.analysis.dependencies_page ? `- **[Dependencies](dependencies.md)** — External packages and their usage\n` : ""}${config.analysis.usage_guide_page ? `- **[Usage Guide](guide.md)** — How to navigate and use these docs\n` : ""}

---

## Languages

${langList}

---

${coreModulesSection}

---

## API by Section

| Section | Modules | Key Files |
|---------|:-------:|-----------|
${sectionLinks}

---

## Entry Points

${meta.entryPoints.map((e) => {
  const slug = e.replace(/\.[^.]+$/, "");
  return `- [\`${e}\`](api/${slug}.md)`;
}).join("\n")}

---

!!! info "About This Documentation"
    This documentation is auto-generated from source code analysis. It covers **${stats.totalFiles} source files** containing **${stats.totalSymbols} symbols** across **${stats.totalLines.toLocaleString()} lines** of code.
    Last generated from commit \`${manifest.commitSha.slice(0, 8)}\`.

---

*Generated by [DocWalk](https://docwalk.dev)*
`;

  return {
    path: "index.md",
    title: "Overview",
    content,
    navGroup: "",
    navOrder: 0,
  };
}

/**
 * Generate an AI-enhanced overview page with narrative prose.
 */
export async function generateOverviewPageNarrative(
  manifest: AnalysisManifest,
  config: DocWalkConfig,
  provider: AIProvider,
  readFile: (filePath: string) => Promise<string>
): Promise<GeneratedPage> {
  const basePage = generateOverviewPage(manifest, config);

  try {
    const narrative = await generateOverviewNarrative({
      provider,
      manifest,
      readFile,
    });

    const repoUrl = config.source.repo.includes("/") ? config.source.repo : undefined;
    const prose = renderCitations(narrative.prose, narrative.citations, repoUrl, config.source.branch);

    // Insert narrative prose after the title, before the template content
    const projectName = resolveProjectName(manifest);
    const narrativeContent = `---
title: ${projectName} Documentation
description: Technical documentation for ${projectName}
---

# ${projectName}

${prose}

---

${basePage.content.split("---\n").slice(2).join("---\n")}`;

    return {
      ...basePage,
      content: narrativeContent,
    };
  } catch {
    // Fallback to template-based page on AI failure
    return basePage;
  }
}
