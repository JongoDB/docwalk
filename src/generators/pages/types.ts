import path from "path";
import type { AnalysisManifest, ModuleInfo, Symbol, GeneratedPage } from "../../analysis/types.js";
import { getLanguageTag, getKindBadge, renderSymbol, groupModulesLogically } from "../utils.js";

export function generateTypesPage(manifest: AnalysisManifest): GeneratedPage {
  // Collect all exported types, interfaces, and enums across modules
  const typeSymbols: Array<{ symbol: Symbol; module: ModuleInfo; group: string }> = [];
  const modulesByGroup = groupModulesLogically(manifest.modules);

  for (const [group, modules] of Object.entries(modulesByGroup)) {
    for (const mod of modules) {
      for (const sym of mod.symbols) {
        if (
          sym.exported &&
          (sym.kind === "interface" || sym.kind === "type" || sym.kind === "enum")
        ) {
          typeSymbols.push({ symbol: sym, module: mod, group });
        }
      }
    }
  }

  // Master summary table â€” split described vs undescribed
  let masterTable = "";
  if (typeSymbols.length > 0) {
    const described = typeSymbols.filter(({ symbol: sym }) => sym.docs?.summary || sym.aiSummary);
    const undescribed = typeSymbols.filter(({ symbol: sym }) => !sym.docs?.summary && !sym.aiSummary);

    // Described types get the full 4-column table
    if (described.length > 0) {
      masterTable += `| Name | Kind | Module | Description |\n`;
      masterTable += `|------|------|--------|-------------|\n`;
      for (const { symbol: sym, module: mod } of described) {
        const kindBadge = getKindBadge(sym.kind);
        const desc = sym.docs?.summary || sym.aiSummary || "";
        const symAnchor = sym.name.toLowerCase().replace(/[^a-z0-9-_]/g, "");
        masterTable += `| [\`${sym.name}\`](#${symAnchor}) | ${kindBadge} | \`${path.basename(mod.filePath)}\` | ${desc} |\n`;
      }
      masterTable += "\n";
    }

    // Undescribed types get a compact 3-column table (no empty Description column)
    if (undescribed.length > 0) {
      if (described.length > 0) {
        masterTable += `### Other Types\n\n`;
      }
      masterTable += `| Name | Kind | Module |\n`;
      masterTable += `|------|------|--------|\n`;
      for (const { symbol: sym, module: mod } of undescribed) {
        const kindBadge = getKindBadge(sym.kind);
        const symAnchor = sym.name.toLowerCase().replace(/[^a-z0-9-_]/g, "");
        masterTable += `| [\`${sym.name}\`](#${symAnchor}) | ${kindBadge} | \`${path.basename(mod.filePath)}\` |\n`;
      }
      masterTable += "\n";
    }
  }

  // Detailed sections grouped by logical section
  let detailedSections = "";
  const groupedTypes = new Map<string, Array<{ symbol: Symbol; module: ModuleInfo }>>();
  for (const entry of typeSymbols) {
    if (!groupedTypes.has(entry.group)) groupedTypes.set(entry.group, []);
    groupedTypes.get(entry.group)!.push(entry);
  }

  for (const [group, entries] of groupedTypes) {
    detailedSections += `## ${group}\n\n`;
    for (const { symbol: sym, module: mod } of entries) {
      const langTag = getLanguageTag(mod.language);
      detailedSections += renderSymbol(sym, langTag);
    }
  }

  const content = `---
title: Types & Interfaces
description: Aggregate type definitions, interfaces, and enums
---

# Types & Interfaces

All exported types, interfaces, and enums across the codebase.

!!! info "Summary"
    **${typeSymbols.length}** type definitions found across **${new Set(typeSymbols.map((t) => t.module.filePath)).size}** modules.

---

${masterTable ? `## Overview\n\n${masterTable}---\n\n` : ""}${detailedSections || "!!! note \"No exported types found\"\n    No exported interfaces, types, or enums were detected in the analyzed source.\n"}

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

  return {
    path: "types.md",
    title: "Types & Interfaces",
    content,
    navGroup: "",
    navOrder: 4,
    audience: "developer",
  };
}
