import path from "path";
import type { AnalysisManifest, GeneratedPage } from "../../analysis/types.js";
import { sanitizeMermaidId } from "../utils.js";

export function generateArchitecturePage(
  manifest: AnalysisManifest
): GeneratedPage {
  const { dependencyGraph } = manifest;

  // Cluster nodes by top-level directory
  const clusters = new Map<string, string[]>();
  for (const node of dependencyGraph.nodes) {
    const parts = node.split("/");
    const dir = parts.length > 2 ? parts.slice(0, 2).join("/") : parts[0];
    if (!clusters.has(dir)) clusters.set(dir, []);
    clusters.get(dir)!.push(node);
  }

  // Build connection count for each node to find top N
  const connectionCounts = new Map<string, number>();
  for (const edge of dependencyGraph.edges) {
    connectionCounts.set(edge.from, (connectionCounts.get(edge.from) ?? 0) + 1);
    connectionCounts.set(edge.to, (connectionCounts.get(edge.to) ?? 0) + 1);
  }

  // Limit to top 30 most-connected nodes for readability
  const topNodes = new Set(
    [...connectionCounts.entries()]
      .sort((a, b) => b[1] - a[1])
      .slice(0, 30)
      .map(([node]) => node)
  );

  // If fewer than 30 total nodes, include all
  if (dependencyGraph.nodes.length <= 30) {
    for (const node of dependencyGraph.nodes) {
      topNodes.add(node);
    }
  }

  // Guard: no nodes in dependency graph
  if (dependencyGraph.nodes.length === 0) {
    const content = `---
title: Architecture
description: System architecture and dependency graph
---

# Architecture

## Dependency Graph

!!! info "Architecture diagram unavailable"
    No dependency relationships were detected between analyzed files.
    This can happen when files don't import from each other or when
    the project uses non-standard import patterns.

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

    return {
      path: "architecture.md",
      title: "Architecture",
      content,
      navGroup: "",
      navOrder: 2,
    };
  }

  // Assign colors by directory cluster
  const dirColors = [":::blue", ":::green", ":::orange", ":::pink", ":::purple"];
  const dirColorMap = new Map<string, string>();
  let colorIdx = 0;
  for (const [dir] of clusters) {
    dirColorMap.set(dir, dirColors[colorIdx % dirColors.length]);
    colorIdx++;
  }

  // Build Mermaid graph with subgraphs
  // Use top-down layout for large graphs to avoid horizontal overflow
  const graphDirection = topNodes.size > 15 ? "TD" : "LR";
  let mermaidContent = `graph ${graphDirection}\n`;

  // Add subgraphs for each directory
  for (const [dir, nodes] of clusters) {
    const filteredNodes = nodes.filter((n) => topNodes.has(n));
    if (filteredNodes.length === 0) continue;

    mermaidContent += `  subgraph ${sanitizeMermaidId(dir)}["${dir}"]\n`;
    for (const node of filteredNodes) {
      mermaidContent += `    ${sanitizeMermaidId(node)}["${path.basename(node)}"]\n`;
    }
    mermaidContent += "  end\n";
  }

  // Add edges (only between visible nodes)
  const visibleEdges = dependencyGraph.edges.filter(
    (e) => topNodes.has(e.from) && topNodes.has(e.to)
  );
  for (const edge of visibleEdges.slice(0, 100)) {
    const style = edge.isTypeOnly ? "-.->" : "-->";
    mermaidContent += `  ${sanitizeMermaidId(edge.from)} ${style} ${sanitizeMermaidId(edge.to)}\n`;
  }

  // Module relationship table sorted by connections
  const moduleRows = manifest.modules
    .map((m) => {
      const outgoing = dependencyGraph.edges.filter((e) => e.from === m.filePath).length;
      const incoming = dependencyGraph.edges.filter((e) => e.to === m.filePath).length;
      return { filePath: m.filePath, deps: outgoing, dependents: incoming, total: outgoing + incoming };
    })
    .sort((a, b) => b.total - a.total)
    .slice(0, 30);

  const content = `---
title: Architecture
description: System architecture and dependency graph
---

# Architecture

## Dependency Graph

!!! info "Graph Legend"
    Solid arrows (\`→\`) are value imports. Dashed arrows (\`⇢\`) are type-only imports.
    Nodes are clustered by directory. Only the ${topNodes.size} most-connected modules are shown.

\`\`\`mermaid
${mermaidContent}\`\`\`

${dependencyGraph.nodes.length > 30 ? `\n!!! note "Showing ${topNodes.size} of ${dependencyGraph.nodes.length} modules"\n    The full graph has ${dependencyGraph.nodes.length} nodes and ${dependencyGraph.edges.length} edges.\n` : ""}

## Module Relationships

| Module | Dependencies | Dependents | Total |
|--------|:-----------:|:----------:|:-----:|
${moduleRows.map((r) => {
  const slug = r.filePath.replace(/\.[^.]+$/, "");
  return `| [\`${r.filePath}\`](api/${slug}.md) | ${r.deps} | ${r.dependents} | **${r.total}** |`;
}).join("\n")}

## Statistics

| Metric | Value |
|--------|-------|
| Modules in graph | **${dependencyGraph.nodes.length}** |
| Dependency edges | **${dependencyGraph.edges.length}** |
| Type-only imports | **${dependencyGraph.edges.filter((e) => e.isTypeOnly).length}** |
| Avg dependencies/module | **${dependencyGraph.nodes.length > 0 ? (dependencyGraph.edges.length / dependencyGraph.nodes.length).toFixed(1) : "0"}** |

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

  return {
    path: "architecture.md",
    title: "Architecture",
    content,
    navGroup: "",
    navOrder: 2,
  };
}

export function generateTieredArchitecturePages(manifest: AnalysisManifest): GeneratedPage[] {
  const pages: GeneratedPage[] = [];
  const { dependencyGraph } = manifest;

  // Guard: no nodes in dependency graph
  if (dependencyGraph.nodes.length === 0) {
    pages.push({
      path: "architecture/index.md",
      title: "Architecture",
      content: `---
title: Architecture
description: System architecture overview
---

# Architecture

## System Overview

!!! info "Architecture diagram unavailable"
    No dependency relationships were detected between analyzed files.
    This can happen when files don't import from each other or when
    the project uses non-standard import patterns.

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`,
      navGroup: "Architecture",
      navOrder: 2,
    });
    return pages;
  }

  // Cluster nodes by top-level directory
  const packageMap = new Map<string, string[]>();
  for (const node of dependencyGraph.nodes) {
    const parts = node.split("/");
    const dir = parts.length > 2 ? parts.slice(0, 2).join("/") : parts[0];
    if (!packageMap.has(dir)) packageMap.set(dir, []);
    packageMap.get(dir)!.push(node);
  }

  // ── Tier 1: System Overview ────────────────────────────────────────────
  let t1Content = `---
title: Architecture
description: System architecture overview
---

# Architecture

## System Overview

High-level view of the project's package/directory structure and their relationships.

\`\`\`mermaid
graph ${packageMap.size > 15 ? "TD" : "LR"}
`;

  // Package-level subgraphs
  for (const [dir, nodes] of packageMap) {
    const dirId = sanitizeMermaidId(dir);
    t1Content += `  ${dirId}["${dir} (${nodes.length} files)"]\n`;
  }

  // Cross-package edges
  const crossPkgEdges = new Set<string>();
  for (const edge of dependencyGraph.edges) {
    const fromParts = edge.from.split("/");
    const toParts = edge.to.split("/");
    const fromDir = fromParts.length > 2 ? fromParts.slice(0, 2).join("/") : fromParts[0];
    const toDir = toParts.length > 2 ? toParts.slice(0, 2).join("/") : toParts[0];
    if (fromDir !== toDir) {
      const key = `${fromDir}|${toDir}`;
      if (!crossPkgEdges.has(key)) {
        crossPkgEdges.add(key);
        const style = edge.isTypeOnly ? "-.->" : "-->";
        t1Content += `  ${sanitizeMermaidId(fromDir)} ${style} ${sanitizeMermaidId(toDir)}\n`;
      }
    }
  }

  t1Content += `\`\`\`

## Packages

| Package | Files | Symbols | Key Exports |
|---------|:-----:|:-------:|-------------|
`;

  for (const [dir, nodes] of packageMap) {
    const dirSlug = dir;
    const modulesInDir = manifest.modules.filter((m) => nodes.includes(m.filePath));
    const totalSymbols = modulesInDir.reduce((s, m) => s + m.symbols.length, 0);
    const keyExports = modulesInDir
      .flatMap((m) => m.symbols.filter((s) => s.exported))
      .slice(0, 3)
      .map((s) => `\`${s.name}\``)
      .join(", ");
    t1Content += `| [**${dir}**](${dirSlug}.md) | ${nodes.length} | ${totalSymbols} | ${keyExports || "—"} |\n`;
  }

  t1Content += `
---

## Statistics

| Metric | Value |
|--------|-------|
| Total packages | **${packageMap.size}** |
| Total modules | **${dependencyGraph.nodes.length}** |
| Total edges | **${dependencyGraph.edges.length}** |
| Cross-package edges | **${crossPkgEdges.size}** |

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

  pages.push({
    path: "architecture/index.md",
    title: "Architecture",
    content: t1Content,
    navGroup: "",
    navOrder: 2,
  });

  // ── Tier 2: Package Detail — one per directory ─────────────────────────
  for (const [dir, nodes] of packageMap) {
    const dirSlug = dir;
    const modulesInDir = manifest.modules.filter((m) => nodes.includes(m.filePath));

    let t2Content = `---
title: "${dir}"
description: "Architecture detail for ${dir}"
---

# ${dir}

## Module Graph

\`\`\`mermaid
graph ${nodes.length > 15 ? "TD" : "LR"}
`;

    for (const node of nodes) {
      const nodeId = sanitizeMermaidId(node);
      const isEntry = node.includes("index.") || node.includes("main.");
      t2Content += `  ${nodeId}["${path.basename(node)}"]${isEntry ? "\n  style " + nodeId + " fill:#5de4c7,color:#000" : ""}\n`;
    }

    const nodesSet = new Set(nodes);
    for (const edge of dependencyGraph.edges) {
      if (nodesSet.has(edge.from) && nodesSet.has(edge.to)) {
        const style = edge.isTypeOnly ? "-.->" : "-->";
        t2Content += `  ${sanitizeMermaidId(edge.from)} ${style} ${sanitizeMermaidId(edge.to)}\n`;
      }
    }

    t2Content += `\`\`\`

## Modules

| Module | Dependencies | Dependents | Exports |
|--------|:-----------:|:----------:|:-------:|
`;

    for (const mod of modulesInDir) {
      const deps = dependencyGraph.edges.filter((e) => e.from === mod.filePath).length;
      const dependents = dependencyGraph.edges.filter((e) => e.to === mod.filePath).length;
      const exports = mod.symbols.filter((s) => s.exported).length;
      const modSlug = mod.filePath.replace(/\.[^.]+$/, "");
      t2Content += `| [\`${path.basename(mod.filePath)}\`](../api/${modSlug}.md) | ${deps} | ${dependents} | ${exports} |\n`;
    }

    t2Content += `
---

*Part of the [Architecture](index.md) overview*
`;

    pages.push({
      path: `architecture/${dirSlug}.md`,
      title: dir,
      content: t2Content,
      navGroup: "Architecture",
      navOrder: 2,
    });
  }

  return pages;
}
