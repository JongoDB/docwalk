import path from "path";
import type { DocWalkConfig } from "../../config/schema.js";
import type { AnalysisManifest, GeneratedPage } from "../../analysis/types.js";

export function generateDependenciesPage(manifest: AnalysisManifest): GeneratedPage {
  // Collect external imports (source doesn't start with . or /)
  const externalDeps = new Map<string, { modules: Set<string>; typeOnly: boolean }>();

  for (const mod of manifest.modules) {
    for (const imp of mod.imports) {
      if (imp.source.startsWith(".") || imp.source.startsWith("/")) continue;

      // Extract package name (handle scoped packages like @scope/pkg)
      const parts = imp.source.split("/");
      const pkgName = imp.source.startsWith("@") && parts.length >= 2
        ? `${parts[0]}/${parts[1]}`
        : parts[0];

      if (!externalDeps.has(pkgName)) {
        externalDeps.set(pkgName, { modules: new Set(), typeOnly: true });
      }
      const entry = externalDeps.get(pkgName)!;
      entry.modules.add(mod.filePath);
      if (!imp.isTypeOnly) entry.typeOnly = false;
    }
  }

  // Sort by usage frequency
  const sorted = [...externalDeps.entries()]
    .sort((a, b) => b[1].modules.size - a[1].modules.size);

  let tableContent = "";
  if (sorted.length > 0) {
    tableContent += `| Package | Used By | Import Type |\n`;
    tableContent += `|---------|:-------:|:-----------:|\n`;
    for (const [pkg, info] of sorted) {
      const importType = info.typeOnly ? ":material-tag: type-only" : ":material-package-variant: value";
      tableContent += `| \`${pkg}\` | ${info.modules.size} module${info.modules.size > 1 ? "s" : ""} | ${importType} |\n`;
    }
    tableContent += "\n";
  }

  // Detailed usage per package
  let detailedContent = "";
  for (const [pkg, info] of sorted.slice(0, 30)) {
    detailedContent += `### \`${pkg}\`\n\n`;
    detailedContent += `Used by ${info.modules.size} module${info.modules.size > 1 ? "s" : ""}:\n\n`;
    for (const modPath of [...info.modules].sort()) {
      const slug = modPath.replace(/\.[^.]+$/, "");
      detailedContent += `- [\`${modPath}\`](api/${slug}.md)\n`;
    }
    detailedContent += "\n";
  }

  const content = `---
title: Dependencies
description: External dependencies and their usage
---

# Dependencies

External packages imported across the codebase.

!!! info "Summary"
    **${sorted.length}** external packages detected across **${manifest.modules.length}** modules.

---

## Package Overview

${tableContent || "*No external dependencies detected.*\n"}

---

## Usage Details

${detailedContent || "*No external dependencies to detail.*\n"}

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

  return {
    path: "dependencies.md",
    title: "Dependencies",
    content,
    navGroup: "",
    navOrder: 5,
    audience: "developer",
  };
}

export function generateSBOMPage(manifest: AnalysisManifest, config: DocWalkConfig): GeneratedPage {
  // Collect external imports (source doesn't start with . or /)
  const externalDeps = new Map<string, { modules: Set<string>; typeOnly: boolean }>();

  for (const mod of manifest.modules) {
    for (const imp of mod.imports) {
      if (imp.source.startsWith(".") || imp.source.startsWith("/")) continue;

      const parts = imp.source.split("/");
      const pkgName = imp.source.startsWith("@") && parts.length >= 2
        ? `${parts[0]}/${parts[1]}`
        : parts[0];

      if (!externalDeps.has(pkgName)) {
        externalDeps.set(pkgName, { modules: new Set(), typeOnly: true });
      }
      const entry = externalDeps.get(pkgName)!;
      entry.modules.add(mod.filePath);
      if (!imp.isTypeOnly) entry.typeOnly = false;
    }
  }

  const sorted = [...externalDeps.entries()]
    .sort((a, b) => b[1].modules.size - a[1].modules.size);

  // Categorize into runtime vs dev vs peer (heuristic: type-only = dev)
  const runtime = sorted.filter(([, info]) => !info.typeOnly);
  const devOnly = sorted.filter(([, info]) => info.typeOnly);

  let tableContent = "";
  if (sorted.length > 0) {
    tableContent += `| Package | Version | License | Used By | Category |\n`;
    tableContent += `|---------|---------|---------|:-------:|:---------:|\n`;
    for (const [pkg, info] of sorted) {
      const category = info.typeOnly ? ":material-wrench: Dev" : ":material-package-variant: Runtime";
      tableContent += `| \`${pkg}\` | — | — | ${info.modules.size} module${info.modules.size > 1 ? "s" : ""} | ${category} |\n`;
    }
    tableContent += "\n";
  }

  // Detailed usage per package
  let detailedContent = "";
  for (const [pkg, info] of sorted.slice(0, 30)) {
    detailedContent += `### \`${pkg}\`\n\n`;
    detailedContent += `Used by ${info.modules.size} module${info.modules.size > 1 ? "s" : ""}:\n\n`;
    for (const modPath of [...info.modules].sort()) {
      const slug = modPath.replace(/\.[^.]+$/, "");
      detailedContent += `- [\`${modPath}\`](api/${slug}.md)\n`;
    }
    detailedContent += "\n";
  }

  const content = `---
title: Software Bill of Materials
description: Dependencies, versions, and licenses
---

# Software Bill of Materials

External packages imported across the codebase with categorization.

!!! info "Summary"
    **${sorted.length}** external packages detected: **${runtime.length}** runtime, **${devOnly.length}** dev/type-only.

---

## Dependency Overview

${tableContent || "*No external dependencies detected.*\n"}

---

## Runtime Dependencies

${runtime.length > 0 ? runtime.map(([pkg, info]) => `- \`${pkg}\` — ${info.modules.size} module${info.modules.size > 1 ? "s" : ""}`).join("\n") : "*None detected.*"}

---

## Dev / Type-only Dependencies

${devOnly.length > 0 ? devOnly.map(([pkg, info]) => `- \`${pkg}\` — ${info.modules.size} module${info.modules.size > 1 ? "s" : ""}`).join("\n") : "*None detected.*"}

---

## Usage Details

${detailedContent || "*No external dependencies to detail.*\n"}

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

  return {
    path: "dependencies.md",
    title: "Software Bill of Materials",
    content,
    navGroup: "",
    navOrder: 5,
    audience: "developer",
  };
}
