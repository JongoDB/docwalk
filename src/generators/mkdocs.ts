/**
 * DocWalk Generator â€” MkDocs Material
 *
 * Transforms an AnalysisManifest into a complete MkDocs Material
 * documentation site: Markdown pages, mkdocs.yml, navigation tree,
 * and supporting assets.
 */

import { mkdir, writeFile } from "fs/promises";
import path from "path";
import type { DocWalkConfig } from "../config/schema.js";
import type {
  AnalysisManifest,
  ModuleInfo,
  Symbol,
  GeneratedPage,
  NavigationItem,
} from "../analysis/types.js";
import { getLanguageDisplayName, type LanguageId } from "../analysis/language-detect.js";

export interface GenerateOptions {
  manifest: AnalysisManifest;
  config: DocWalkConfig;
  outputDir: string;
  onProgress?: (message: string) => void;
}

/**
 * Generate a complete MkDocs Material documentation site.
 */
export async function generateDocs(options: GenerateOptions): Promise<void> {
  const { manifest, config, outputDir, onProgress } = options;

  const docsDir = path.join(outputDir, "docs");
  await mkdir(docsDir, { recursive: true });

  // â”€â”€ 1. Generate pages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const pages: GeneratedPage[] = [];

  // Index / overview page
  onProgress?.("Generating overview page...");
  pages.push(generateOverviewPage(manifest));

  // Getting Started
  pages.push(generateGettingStartedPage(manifest));

  // Architecture page
  if (config.analysis.dependency_graph) {
    onProgress?.("Generating architecture page...");
    pages.push(generateArchitecturePage(manifest));
  }

  // API Reference pages â€” one per module
  onProgress?.("Generating API reference pages...");
  const modulesByGroup = groupModulesByDirectory(manifest.modules);
  for (const [group, modules] of Object.entries(modulesByGroup)) {
    for (const mod of modules) {
      pages.push(generateModulePage(mod, group));
    }
  }

  // Changelog
  if (config.analysis.changelog) {
    pages.push(generateChangelogPage());
  }

  // â”€â”€ 2. Write all pages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (const page of pages) {
    const pagePath = path.join(docsDir, page.path);
    await mkdir(path.dirname(pagePath), { recursive: true });
    await writeFile(pagePath, page.content);
    onProgress?.(`Written: ${page.path}`);
  }

  // â”€â”€ 3. Generate mkdocs.yml â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  onProgress?.("Generating mkdocs.yml...");
  const navigation = buildNavigation(pages);
  const mkdocsYml = generateMkdocsConfig(manifest, config, navigation);
  await writeFile(path.join(outputDir, "mkdocs.yml"), mkdocsYml);

  onProgress?.(`Documentation generated: ${pages.length} pages`);
}

// â”€â”€â”€ Page Generators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateOverviewPage(manifest: AnalysisManifest): GeneratedPage {
  const { projectMeta: meta, stats } = manifest;

  const langTable = meta.languages
    .map((l) => `| ${l.name} | ${l.fileCount} | ${l.percentage}% |`)
    .join("\n");

  const content = `---
title: Overview
---

# ${meta.name}

${meta.description || `Documentation for the ${meta.name} codebase.`}

## Project Summary

| Metric | Value |
|--------|-------|
| **Total Files** | ${stats.totalFiles} |
| **Total Symbols** | ${stats.totalSymbols} |
| **Total Lines** | ${stats.totalLines.toLocaleString()} |
| **Languages** | ${meta.languages.length} |

## Language Breakdown

| Language | Files | Share |
|----------|-------|-------|
${langTable}

## Entry Points

${meta.entryPoints.map((e) => `- \`${e}\``).join("\n")}

## Quick Links

- [Getting Started](getting-started.md) â€” Setup and usage guide
- [Architecture](architecture.md) â€” System design and dependency graph
- [API Reference](api/) â€” Complete API documentation

---

*Generated by [DocWalk](https://docwalk.dev) from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

  return {
    path: "index.md",
    title: "Overview",
    content,
    navGroup: "",
    navOrder: 0,
  };
}

function generateGettingStartedPage(
  manifest: AnalysisManifest
): GeneratedPage {
  const meta = manifest.projectMeta;

  const content = `---
title: Getting Started
---

# Getting Started

## Prerequisites

${meta.languages.map((l) => `- ${l.name} development environment`).join("\n")}

## Installation

\`\`\`bash
# Clone the repository
git clone ${meta.repository ? `https://github.com/${meta.repository}` : "<repository-url>"}
cd ${meta.name}

# Install dependencies
${meta.packageManager === "yarn" ? "yarn install" : meta.packageManager === "pnpm" ? "pnpm install" : "npm install"}
\`\`\`

## Project Structure

\`\`\`
${generateDirectoryTree(manifest.modules)}
\`\`\`

## Entry Points

${meta.entryPoints.map((e) => `- [\`${e}\`](api/${e.replace(/\.[^.]+$/, "").replace(/\//g, "-")}.md)`).join("\n")}

---

*Auto-generated by DocWalk. Update your source code and re-sync to keep this page current.*
`;

  return {
    path: "getting-started.md",
    title: "Getting Started",
    content,
    navGroup: "",
    navOrder: 1,
  };
}

function generateArchitecturePage(
  manifest: AnalysisManifest
): GeneratedPage {
  const { dependencyGraph } = manifest;

  const mermaidNodes = dependencyGraph.nodes
    .slice(0, 50)
    .map((n) => `  ${sanitizeMermaidId(n)}["${path.basename(n)}"]`)
    .join("\n");

  const mermaidEdges = dependencyGraph.edges
    .slice(0, 100)
    .map(
      (e) =>
        `  ${sanitizeMermaidId(e.from)} --> ${sanitizeMermaidId(e.to)}`
    )
    .join("\n");

  const content = `---
title: Architecture
---

# Architecture

## Dependency Graph

\`\`\`mermaid
graph LR
${mermaidNodes}
${mermaidEdges}
\`\`\`

## Module Relationships

| Module | Dependencies | Dependents |
|--------|-------------|------------|
${manifest.modules
  .slice(0, 30)
  .map((m) => {
    const deps = dependencyGraph.edges.filter(
      (e) => e.from === m.filePath
    ).length;
    const dependents = dependencyGraph.edges.filter(
      (e) => e.to === m.filePath
    ).length;
    return `| \`${m.filePath}\` | ${deps} | ${dependents} |`;
  })
  .join("\n")}

## Statistics

- **${dependencyGraph.nodes.length}** modules in the dependency graph
- **${dependencyGraph.edges.length}** dependency edges
- Average dependencies per module: **${dependencyGraph.nodes.length > 0 ? (dependencyGraph.edges.length / dependencyGraph.nodes.length).toFixed(1) : 0}**

---

*Generated by DocWalk from commit \`${manifest.commitSha.slice(0, 8)}\`*
`;

  return {
    path: "architecture.md",
    title: "Architecture",
    content,
    navGroup: "",
    navOrder: 2,
  };
}

function generateModulePage(mod: ModuleInfo, group: string): GeneratedPage {
  const slug = mod.filePath
    .replace(/\.[^.]+$/, "")
    .replace(/\//g, "-");

  const publicSymbols = mod.symbols.filter((s) => s.exported);
  const privateSymbols = mod.symbols.filter((s) => !s.exported);

  let content = `---
title: "${path.basename(mod.filePath)}"
---

# ${path.basename(mod.filePath)}

\`${mod.filePath}\` Â· ${getLanguageDisplayName(mod.language as LanguageId)} Â· ${mod.lineCount} lines

${mod.moduleDoc?.summary || mod.aiSummary || ""}

`;

  // Exports summary
  if (publicSymbols.length > 0) {
    content += `## Exports\n\n`;
    content += `| Name | Kind | Description |\n`;
    content += `|------|------|-------------|\n`;
    for (const sym of publicSymbols) {
      content += `| [\`${sym.name}\`](#${sym.name.toLowerCase()}) | ${sym.kind} | ${sym.docs?.summary || ""} |\n`;
    }
    content += "\n";
  }

  // Detailed symbol docs
  if (publicSymbols.length > 0) {
    content += `## API\n\n`;
    for (const sym of publicSymbols) {
      content += renderSymbol(sym);
    }
  }

  // Imports
  if (mod.imports.length > 0) {
    content += `## Dependencies\n\n`;
    for (const imp of mod.imports) {
      const names = imp.specifiers.map((s) => s.alias || s.name).join(", ");
      content += `- \`${imp.source}\`${names ? ` â€” ${names}` : ""}\n`;
    }
    content += "\n";
  }

  // Internal symbols
  if (privateSymbols.length > 0) {
    content += `## Internal\n\n`;
    content += `<details>\n<summary>${privateSymbols.length} internal symbols</summary>\n\n`;
    for (const sym of privateSymbols) {
      content += `- \`${sym.name}\` (${sym.kind})\n`;
    }
    content += `\n</details>\n\n`;
  }

  content += `---\n\n*Source: \`${mod.filePath}\` Â· Last analyzed: ${mod.analyzedAt}*\n`;

  return {
    path: `api/${slug}.md`,
    title: path.basename(mod.filePath),
    content,
    navGroup: group || "API Reference",
    navOrder: 10,
  };
}

function generateChangelogPage(): GeneratedPage {
  const content = `---
title: Changelog
---

# Changelog

*Auto-generated from git history. Updates on each sync.*

<!-- DocWalk will populate this from git log -->

---

*Generated by DocWalk*
`;

  return {
    path: "changelog.md",
    title: "Changelog",
    content,
    navGroup: "",
    navOrder: 99,
  };
}

// â”€â”€â”€ Symbol Renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderSymbol(sym: Symbol): string {
  let md = `### \`${sym.name}\`\n\n`;

  if (sym.docs?.deprecated) {
    md += `!!! warning "Deprecated"\n    ${typeof sym.docs.deprecated === "string" ? sym.docs.deprecated : "This API is deprecated."}\n\n`;
  }

  if (sym.signature) {
    md += `\`\`\`typescript\n${sym.signature}\n\`\`\`\n\n`;
  }

  if (sym.docs?.summary) {
    md += `${sym.docs.summary}\n\n`;
  }

  if (sym.docs?.description && sym.docs.description !== sym.docs.summary) {
    md += `${sym.docs.description}\n\n`;
  }

  if (sym.parameters && sym.parameters.length > 0) {
    md += `**Parameters:**\n\n`;
    md += `| Name | Type | Description |\n`;
    md += `|------|------|-------------|\n`;
    for (const param of sym.parameters) {
      md += `| \`${param.name}\` | \`${param.type || "unknown"}\` | ${param.description || ""} |\n`;
    }
    md += "\n";
  } else if (sym.docs?.params) {
    md += `**Parameters:**\n\n`;
    md += `| Name | Description |\n`;
    md += `|------|-------------|\n`;
    for (const [name, desc] of Object.entries(sym.docs.params)) {
      md += `| \`${name}\` | ${desc} |\n`;
    }
    md += "\n";
  }

  if (sym.returns?.type || sym.docs?.returns) {
    md += `**Returns:** ${sym.returns?.type ? `\`${sym.returns.type}\`` : ""} ${sym.docs?.returns || ""}\n\n`;
  }

  md += "---\n\n";
  return md;
}

// â”€â”€â”€ Navigation Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildNavigation(pages: GeneratedPage[]): NavigationItem[] {
  const nav: NavigationItem[] = [];

  // Top-level pages
  const topLevel = pages
    .filter((p) => !p.path.includes("/"))
    .sort((a, b) => a.navOrder - b.navOrder);

  for (const page of topLevel) {
    nav.push({ title: page.title, path: page.path });
  }

  // Grouped pages (API Reference, etc.)
  const groups = new Map<string, GeneratedPage[]>();
  for (const page of pages) {
    if (page.path.includes("/")) {
      const group = page.navGroup || page.path.split("/")[0];
      if (!groups.has(group)) groups.set(group, []);
      groups.get(group)!.push(page);
    }
  }

  for (const [group, groupPages] of groups) {
    nav.push({
      title: group,
      children: groupPages.map((p) => ({
        title: p.title,
        path: p.path,
      })),
    });
  }

  return nav;
}

// â”€â”€â”€ MkDocs Config Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateMkdocsConfig(
  manifest: AnalysisManifest,
  config: DocWalkConfig,
  navigation: NavigationItem[]
): string {
  const siteName = manifest.projectMeta.name;
  const theme = config.theme;

  const navYaml = navigation
    .map((item) => {
      if (item.children) {
        const children = item.children
          .map((child) => `      - "${child.title}": ${child.path}`)
          .join("\n");
        return `  - "${item.title}":\n${children}`;
      }
      return `  - "${item.title}": ${item.path}`;
    })
    .join("\n");

  const features = theme.features
    .map((f) => `      - ${f}`)
    .join("\n");

  return `# DocWalk Generated Configuration
# Do not edit manually â€” re-run 'docwalk generate' to update

site_name: "${siteName} Documentation"
site_description: "Auto-generated documentation for ${siteName}"
site_url: "${config.domain.custom ? `https://${config.domain.custom}${config.domain.base_path}` : ""}"

repo_url: "https://github.com/${config.source.repo}"
repo_name: "${config.source.repo}"

theme:
  name: material
  palette:
    - scheme: ${theme.palette}
      primary: custom
      accent: custom
      toggle:
        icon: material/brightness-7
        name: Switch to dark mode
    - scheme: slate
      primary: custom
      accent: custom
      toggle:
        icon: material/brightness-4
        name: Switch to light mode
${theme.logo ? `  logo: ${theme.logo}` : ""}
${theme.favicon ? `  favicon: ${theme.favicon}` : ""}
  features:
${features}

extra_css:
  - assets/extra.css

markdown_extensions:
  - admonition
  - pymdownx.details
  - pymdownx.superfences:
      custom_fences:
        - name: mermaid
          class: mermaid
          format: !!python/name:pymdownx.superfences.fence_code_format
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.tabbed:
      alternate_style: true
  - pymdownx.tasklist:
      custom_checkbox: true
  - tables
  - toc:
      permalink: true

plugins:
  - search
  - minify:
      minify_html: true

nav:
${navYaml}

extra:
  generator: false
  social: []
`;
}

// â”€â”€â”€ Utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function groupModulesByDirectory(
  modules: ModuleInfo[]
): Record<string, ModuleInfo[]> {
  const groups: Record<string, ModuleInfo[]> = {};
  for (const mod of modules) {
    const parts = mod.filePath.split("/");
    const group =
      parts.length > 1
        ? parts.slice(0, -1).join("/")
        : "API Reference";
    if (!groups[group]) groups[group] = [];
    groups[group].push(mod);
  }
  return groups;
}

function generateDirectoryTree(modules: ModuleInfo[]): string {
  const dirs = new Set<string>();
  for (const mod of modules) {
    const parts = mod.filePath.split("/");
    for (let i = 1; i <= parts.length; i++) {
      dirs.add(parts.slice(0, i).join("/"));
    }
  }

  const sorted = [...dirs].sort();
  return sorted.slice(0, 30).map((d) => {
    const depth = d.split("/").length - 1;
    const indent = "  ".repeat(depth);
    const name = d.split("/").pop()!;
    const isFile = d.includes(".");
    return `${indent}${isFile ? "" : "ğŸ“ "}${name}`;
  }).join("\n");
}

function sanitizeMermaidId(filePath: string): string {
  return filePath.replace(/[^a-zA-Z0-9]/g, "_");
}
